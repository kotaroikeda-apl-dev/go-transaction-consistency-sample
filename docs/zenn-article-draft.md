# 金融ドメインの整合性をコードで守る

金融や決済のシステムでは、データの整合性が設計の中心になります。  
本稿では口座間送金を題材に、Goのコードで「不変条件」と「トランザクション境界」をどう守るかを扱います。

## 整合性とは何か（金融の例で）

金融システムにおいて、残高のずれやマイナス残高は許容されません。  
自分の銀行口座がシステムの不具合で減っていたら、誰だって銀行に電話するでしょう。

- 口座AからBへ送金したのに、Aだけ減ってBが増えていない
- 残高不足なのに引き落としが通ってしまう

こうした「壊れ方」を防ぐのが**整合性**です。  
整合性設計では、次の2つをはっきり決めることが重要になります。

1. **不変条件** … 絶対に成り立っていてほしいルール（例：残高は常に 0 以上）
2. **トランザクション境界** … どの範囲を「ひとまとまり」で成功 or まとめて取り消すか

**この2つを誰がどこで守るか**をコードで示すのが本稿の目的です。

---

## 整合性を守る3点セット（Domain / UseCase / Infra の責務）

整合性を守るために、役割を3つに分けると理解しやすくなります。

| 役割                     | 担当                   | やること                                                                                                                        |
| ------------------------ | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **不変条件**             | Domain                 | 「残高はマイナスにしない」などを**その型のメソッド内**で保証します。外から残高を直接いじらせません。                            |
| **トランザクション境界** | Application（UseCase） | 「この一連の処理を1本のトランザクションで実行する」と**境界を明示**します（後述の `RunInTx`）。                                 |
| **永続化**               | Infrastructure         | 集約の取得・保存は Repository に任せます。DB に書くかメモリに置くかといった保存先の詳細は、UseCase からは見えないようにします。 |

- **Domain** … `Account` のような集約ルートが、`Debit` / `Credit` だけを窓口にし、残高不足ならエラーを返して変更しません。
- **UseCase** … 送金なら「2口座の取得 → Debit/Credit → Save」までを、**1つのトランザクション**として実行する責務を持ちます。
- **Infra** … 「口座を1件取得する」「口座を保存する」を実装する層です。InMemory なら map、DB なら SQL で書きます。UseCase はどちらの実装か知らず、同じインターフェース（GetByID / Save）としてだけ使います。

大事なのは用語ではなく、**誰が何を守るか**の分担をはっきりさせることです。

---

## サンプル解説（どんな処理の流れか）

題材は**口座間送金**です。  
不変条件は「残高はマイナスにならない」だけに絞ります。

**1. トランザクション境界の明示（UseCase）**

送金処理は「取得 → 引き落とし → 入金 → 保存」を**ひと塊**でやりたいです。  
そこで `TxManager.RunInTx` に処理を渡します。

```go
// (ここに usecase/transfer.go の Execute 内、RunInTx に fn を渡している部分を貼る)
return uc.tx.RunInTx(ctx, func(ctx context.Context) error {
    from, err := uc.repo.GetByID(ctx, fromID)
    // ... to 取得、from.Debit、to.Credit、Save(from)、Save(to)
    return nil
})
```

`RunInTx` の外側が「トランザクションの境界」だと読めます。  
実装が InMemory でも DB でも、**境界の置き場所は UseCase で揃えます**。

**2. 不変条件は Domain で守る**

残高の変更は `Account` のメソッド経由だけにします。  
`balance` は非公開にして、引き落としは `Debit` に任せます。

```go
// (ここに domain/account.go の Debit の残高チェック部分を貼る)
if a.balance < amount {
    return ErrInsufficientBalance
}
a.balance -= amount
```

「残高が足りなければ変更しない」というルールは、**Domain の一箇所**に閉じます。  
Handler や UseCase に「if balance < amount then ...」を書かせません。

**3. 永続化は Repository に隠す**

UseCase は `GetByID` / `Save` というインターフェースだけに依存します。  
保存先が InMemory でも DB でも、UseCase のコードは同じでよいです。

---

## アンチパターン集（3つ）

実装でやりがちな崩し方を3つ挙げます。

**1. Handler 層で BEGIN/COMMIT して、ドメインが散らばる**

HTTP Handler で `tx.Begin()` を握り、その中で「残高チェック」や「足りなければロールバック」を書いてしまうパターンです。  
トランザクション境界が「どの UseCase の単位か」ではなく「1リクエスト」に張り付き、**「送金」という業務の単位**がコードから読み取りづらくなります。  
トランザクションは **UseCase の RunInTx のような境界**で明示し、Handler は「UseCase を呼ぶだけ」にした方がよいです。

**2. Balance を外から直接書き換える**

`account.Balance = account.Balance - amount` のように、外から `balance` を触れるようにしてしまうと、不変条件を守る責任がどこにもありません。  
「残高を変えていいのは Account の Debit/Credit だけ」にすると、不変条件違反は Domain の一箇所で防げます。

**3. Repository が勝手に Tx 管理して境界が曖昧になる**

「GetByID のたびに Tx を張る」「Save の中で Commit する」など、Repository 実装がトランザクションの開始・終了を持ってしまうと、「送金という1本の Tx」の境界が読み取れなくなります。  
トランザクションの「どこからどこまで」は UseCase（RunInTx）で決め、Repository は「渡された ctx の Tx を使うだけ」にしておく方が、整合性の設計が伝わりやすいです。

---

## まとめ

- 金融では「少し壊れる」が許されないので、**整合性設計が主役**になります。
- 不変条件は Domain、トランザクション境界は UseCase（RunInTx）、永続化は Infra に分けると、「誰が何を守るか」がコードに表れます。

サンプル全体はリポジトリの `cmd/demo` で動かせます。  
まずは InMemory で「境界」と「不変条件」の置き場所を確認し、あとから DB を差し替えるとよいです。

**サンプルコード（GitHub）**: [kotaroikeda-apl-dev/go-transaction-consistency-sample](https://github.com/kotaroikeda-apl-dev/go-transaction-consistency-sample)

---
